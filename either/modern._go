//go:build disabled

package either

// Either will either be E or A
type Either[E, A any] interface {
	fmt.Stringer
}

type left[E any] struct {
	e E
}

func (left[E]) IsLeft() bool {
	return true
}

type right[A any] struct {
	a A
}

func (right[A]) IsLeft() bool {
	return false
}

func (l left[E]) String() string {
	return fmt.Sprintf("Left[%v]", l.e)
}

func (r right[A]) String() string {
	return fmt.Sprintf("Right[%v]", r.a)
}

func IsLeft[E, A any](val Either[E, A]) bool {
	switch any(val).(type) {
	case left[E]:
		return true
	default:
		return false
	}
}

func IsRight[E, A any](val Either[E, A]) bool {
	return !IsLeft(val)
}

func Left[E, A any](value E) Either[E, A] {
	return left[E]{e: value}
}

func Right[E, A any](value A) Either[E, A] {
	return right[A]{a: value}
}

func fold[E, A, B any](ma Either[E, A], onLeft func(e E) B, onRight func(a A) B) B {
	if IsLeft(ma) {
		return onLeft(ma.(left[E]).e)
	}
	return onRight(ma.(right[A]).a)
}

func Unwrap[E, A any](ma Either[E, A]) (A, E) {
	if IsLeft(ma) {
		var a A
		return a, ma.(left[E]).e
	}
	var E e
	return ma.(right[A]).a, e
}
